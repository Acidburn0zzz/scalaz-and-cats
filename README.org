#+TITLE: ScalaZ and Cats Comparison
#+AUTHOR: Colin
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="/home/colin/code/org-theme.css"/>

This is a comparison of ScalaZ and Cats by someone who isn't predisposed
to either library. It seeks to answer the following question:

#+BEGIN_QUOTE
Should I use ScalaZ or Cats?
#+END_QUOTE

The answer is, of course, "it depends". What's your use-case?

*I want to train my Scala team in Functional Programming fundamentals.*

Lean toward ScalaZ, it has two books written on it. [[https://www.manning.com/books/functional-programming-in-scala][One by its authors]]
and [[https://leanpub.com/fpmortals][one for beginners which assumes a Java background.]]

*I'm writing a performance-sensitive application.*

Lean toward Cats, it tends to be faster in aggregate. Are you using a
database? Consider [[https://github.com/tpolecat/doobie][Doobie]], which uses Cats.

*I want to improve quality-of-life for my Scala devs.*

Any dedicated application of FP concepts will help you organize and simplify
your code. However, Cats has a wider ecosystem of go-to FP libraries
that can bring drastic and immediate wins to your projects.

*I want to port a well-known, general-purpose Haskell library to Scala.*

You'd be a champ to write a backend for both ScalaZ and Cats, but
know that Cats has a head start and has a nice set of ported libraries
already.

*I'm writing a library/application that works with a complex DSL.*

You probably need Recursion Schemes, which are supplied by the [[https://github.com/slamdata/matryoshka][Matryoshka]]
library in ScalaZ-land.

*I care about which stays truer to Haskell.*

ScalaZ does. Its core has a larger API, provides more features up-front,
and tends to keep Haskell function names and operators (e.g. ~<*>~).

*I care about which has more industry backing.*

[[https://www.jetbrains.com/research/devecosystem-2017/scala/][According to this survey]], ScalaZ does.

*I hear the IO Monad can help me logically organize my code.*

Both ScalaZ 7 and Cats have a ~effects~ subpackage which provides an
~IO~ type. They both help you contain "real world" side-effects into
smaller areas of your code base, freeing the rest of it to purity
([[https://en.wikipedia.org/wiki/Referential_transparency][referential transparency]]). They also help you wrangle IO-based
Exceptions.

Cats' ~IO~ is currently faster in aggregate. However, an overhaul
of ~scalaz-effects~ with many orders of magnitude of improvement in
performance is promised [[http://degoes.net/articles/scalaz8-is-the-future][for ScalaZ 8]], so you may want to wait
for that if IO is a great concern to you.

*Futures suck and I hate JVM thread pools. Help?*

[[http://degoes.net/articles/scalaz8-is-the-future][Wait for ScalaZ 8.]]

*Just gimme Monads.*

Then either is fine, you can flip a coin.

** Benchmarks

Benchmarks were performed using the [[https://github.com/ktoso/sbt-jmh][JMH plugin for SBT]].
Vanilla Scala and Haskell results are also included where applicable.

*** Results

/All times are in nanoseconds./

| Benchmark                        | ScalaZ 7.3.0-M18 | Cats 1.0.0-RC1 | Vanilla Scala | Haskell 8.0.2 |
|----------------------------------+------------------+----------------+---------------+---------------|
| ~Eq~ - same list                 | 78,183           | 2.4            | 2.4           | 3,974         |
| ~Eq~ - different list            | 78,884           | 4,039          | 5,150         |               |
| ~Show~ - ~[Int]~                 | 1,000,757        | 43,633         | 41,079        | 46,540        |
| ~Show~ - ~String~                | 216.6            | 3.2            | 2.8           | 199.4         |
| ~Foldable.fold~ on ~[Int]~       | 3,355            | 5,026          | 7,939         | 3,330         |
| ~Foldable.fold~ on ~[Maybe Int]~ | 10,740           | 12,506         |               | 15,440        |
| ~State~ - ~get~                  | 17.9             | 33.3           |               | 4.1           |
| ~State~ - ~>>=~                  | 90               | 139.1          |               | 10.43         |
| ~State~ - ~flatMap~              | 63.9             | 133.3          |               |               |
| ~State~ - countdown              | 4,259,320        | 2,071,480      |               | 6,069         |
| ~StateT~ - countdown             |                  | 4,572,499      |               | 24,070        |
| ~Applicative~ - sum ~(<*>)~      | 31,709           | 32,132         |               | 22,140        |
| ~Applicative~ - sum (cartesian)  | 50,431           | 33,638         |               |               |
| ~IO~ - recurse 1000              | 117,569          | 48,558         |               | 907.7         |
| ~IO~ - recurse 10000             | 1,183,352        | 503,889        |               | 9,095         |
| ~IO~ - recurse 100000            | 11,671,581       | 5,167,355      |               | 89,860        |

/Note:/ For the ~Eq~ typeclass, at least in these benchmarks, ScalaZ consistently
suffered from a strange JVM deoptimization:

#+BEGIN_QUOTE
Warmup Iteration   1: 8967.747 ns/op

Warmup Iteration   2: 15492.176 ns/op

Warmup Iteration   3: 78857.592 ns/op

Warmup Iteration   4: 78532.147 ns/op

Warmup Iteration   5: 78953.201 ns/op

Iteration   1: 79065.639 ns/op

Iteration   2: 78860.625 ns/op

Iteration   3: 80211.784 ns/op

Iteration   4: 78723.984 ns/op

Iteration   5: 79408.957 ns/op
#+END_QUOTE

This occurred for both the "same list" and "different list" benchmarks. Were it not for
the deoptimization, ~Eq~ would perform at least within the same order of magnitude
as Cats and Vanilla Scala. I have no idea what triggers the deopt.

*** Observations

- *Cats' type-safe equality checking is faster than Vanilla Scala.* So, there seems
  to be no reason not to use Cats' ~===~ in all cases.
- *Cats' type-safe String rendering via Show is as fast as Vanilla toString.* So ~.toString~
  should be avoided.
- At the small scale (i.e. a single ~>>=~), ScalaZ tends to be faster.
- At aggregate scale, Cats tends to be faster.
- Neither library performs well on recursive Monadic operations. Haskell is two to
  three orders of magnitude faster in this regard. In particular, GHC heavily optimizes
  both ~IO~ and ~State~ operations.

*** Caveat

As of this writing (2017 November), ScalaZ 8 is still under development but promises
significant performance improvements for their ~IO~ Monad. The benchmarks above
will have to be reran when it is released.

** The API

*** Accessibility

Up front, Cats has much more documentation and usage examples. Their import story
is consistent - for most tasks you only need:

#+BEGIN_SRC scala
  import cats.implicits._
#+END_SRC

ScalaZ has examples to be sure, but I remember endless frustration in my early days
of using it. My pain was caused almost entirely by import hell. From the ScalaZ
README:

#+BEGIN_QUOTE
We've gone to great lengths to give you an a-la-carte importing experience,
but if you prefer an all-you-can-eat buffet, you're in luck.
#+END_QUOTE

Honestly, avoid the a-la-carte imports and just do:

#+BEGIN_SRC scala
  import scalaz._
  import Scalaz._
#+END_SRC

and you'll get all data types, typeclasses, instances, and operators.
If you're willing to do that, then the import experience for both libraries
becomes level.

*** Features

*** Monads and Monadic Recursion

Quote from cats:

#+BEGIN_QUOTE
Because monadic recursion is so common in functional programming but is not stack
safe on the JVM, Cats has chosen to require ~tailRecM~ of all monad
implementations as opposed to just a subset.
#+END_QUOTE

** Library Health and Ecosystems

*** Project Pulses

As of 2017 November 6.

| Project | Releases | Watchers | Stars | Forks | Commits | Prev. Month Commits | ScalaJS | Scala Native |
|---------+----------+----------+-------+-------+---------+---------------------+---------+--------------|
| ScalaZ  |      106 |      257 |  3312 |   534 |    6101 |                  45 | Yes     | Yes          |
| Cats    |       22 |      174 |  2118 |   493 |    3280 |                  51 | Yes     | *No*         |

ScalaZ's numbers are higher, but that's to be expected as it's an older project.
Otherwise the projects seem to be about equally active.
Notably missing is the lack of Scala Native support in Cats.

*** Sub-libraries

The diagram below looks one-sided, but must be taken with a grain of salt. As projects,
Cats and ScalaZ have different aims. Cats has a small, tight core and espouses modularity.
ScalaZ frames itself as a batteries-included standard library for FP in Scala. ScalaZ
certainly has a larger and more featureful API than Cats at current. This will
be increasingly true for the up-coming ScalaZ 8, which aims to provide the equivalent
functionality of Dogs, Monocle, and Matryoshka directly. It also plans to provide
low-level concurrency primitives which see no analogue in Cats or Vanilla Scala.

That in mind, here is a simplified view of their library ecosystems:

[[./ecosystem.png]]

/Notes:/

- Origami is a port of Haskell's [[https://hackage.haskell.org/package/foldl][foldl]] library
- Atto is a port of Haskell's [[https://hackage.haskell.org/package/attoparsec][attoparsec]] library
- Decline is a port of Haskell's [[https://hackage.haskell.org/package/optparse-applicative][optparse-applicative]] library
- Refined is a port of Haskell's [[https://hackage.haskell.org/package/refined][refined]] library
- Monocle is a port of Haskell's [[https://hackage.haskell.org/package/lens][lens]] library

Libraries like ~circe~, ~atto~ and ~decline~ are immense standard-of-living
improvements for Scala developers. I can't imagine that porting these to use
ScalaZ would be hard, but this has yet to be done. In fact, we see the opposite
trend. Libraries like Doobie, Monocle and FS2 have made explicit moves away from
ScalaZ and onto Cats. Circe has this on their front page:

#+BEGIN_QUOTE
Circe depends on cats instead of Scalaz, and the core project has only one dependency (cats-core).
#+END_QUOTE

These are the echoes of the political events that lead to the creation of cats
in the first place. I've heard it said that "the community is more behind cats",
but I'm personally having a hard time confirming that. Factoids:

- Some high-profile libraries have moved from ScalaZ to Cats
- [[https://www.jetbrains.com/research/devecosystem-2017/scala/][ScalaZ sees greater use in industry]]
- Cats' library ecosystem has a greater "standard-of-living" improvement
- [[https://leanpub.com/fpmortals][There is a large book on ScalaZ being written]]

Choosing one over the other based on community support seems dubious.
I'll leave the judgement call up to you.

*** Resources

The tendency is for Cats to have better documentation and examples up-front, while
ScalaZ has an extensive ~examples~ subpackage.

**** ScalaZ

- [[https://leanpub.com/fpmortals][Functional Programming for Mortals]] by Sam Halliday (book)
- [[http://eed3si9n.com/learning-scalaz/index.html][Learning ScalaZ]] by Eugene Yokota (blog series)
- [[http://eed3si9n.com/scalaz-cheat-sheet][Cheatsheet]] (typeclass usage and imports)
- [[https://github.com/scalaz/scalaz][ScalaZ README]]
- [[https://scalaz.github.io/scalaz/#scaladoc][Scaladocs]]

**** Cats

- [[https://typelevel.org/cats/][Cats Website]]
- [[https://typelevel.org/cats/api/][Scaladocs]]
- [[http://eed3si9n.com/herding-cats/][Herding Cats]] by Eugene Yokota (blog series)
